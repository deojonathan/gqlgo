// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package models

import (
	"fmt"
	"io"
	"strconv"
)

type Connection interface {
	IsConnection()
	GetPageInfo() *PageInfo
	GetEdges() []Edge
}

type CreateCategoryResult interface {
	IsCreateCategoryResult()
}

type CreateProductResult interface {
	IsCreateProductResult()
}

type DeleteCategoryResult interface {
	IsDeleteCategoryResult()
}

type DeleteProductResult interface {
	IsDeleteProductResult()
}

type Edge interface {
	IsEdge()
	GetCursor() string
	GetNode() Node
}

type Error interface {
	IsError()
	GetMessage() string
}

type Node interface {
	IsNode()
	GetID() string
}

type UpdateCategoryResult interface {
	IsUpdateCategoryResult()
}

type UpdateProductResult interface {
	IsUpdateProductResult()
}

type Category struct {
	ID                 string                      `json:"id"`
	Name               string                      `json:"name"`
	ProductsConnection *CategoryProductsConnection `json:"productsConnection"`
}

func (Category) IsNode()            {}
func (this Category) GetID() string { return this.ID }

func (Category) IsCreateCategoryResult() {}

func (Category) IsUpdateCategoryResult() {}

func (Category) IsDeleteCategoryResult() {}

type CategoryConnection struct {
	Edges    []*CategoryEdge `json:"edges"`
	PageInfo *PageInfo       `json:"pageInfo"`
}

func (CategoryConnection) IsConnection()               {}
func (this CategoryConnection) GetPageInfo() *PageInfo { return this.PageInfo }
func (this CategoryConnection) GetEdges() []Edge {
	if this.Edges == nil {
		return nil
	}
	interfaceSlice := make([]Edge, 0, len(this.Edges))
	for _, concrete := range this.Edges {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

type CategoryEdge struct {
	Cursor string    `json:"cursor"`
	Node   *Category `json:"node"`
}

func (CategoryEdge) IsEdge()                {}
func (this CategoryEdge) GetCursor() string { return this.Cursor }
func (this CategoryEdge) GetNode() Node     { return *this.Node }

type CategoryFilter struct {
	Name *FilterString `json:"name"`
}

type CategoryProductsConnection struct {
	PageInfo *PageInfo               `json:"pageInfo"`
	Edges    []*CategoryProductsEdge `json:"edges"`
}

func (CategoryProductsConnection) IsConnection()               {}
func (this CategoryProductsConnection) GetPageInfo() *PageInfo { return this.PageInfo }
func (this CategoryProductsConnection) GetEdges() []Edge {
	if this.Edges == nil {
		return nil
	}
	interfaceSlice := make([]Edge, 0, len(this.Edges))
	for _, concrete := range this.Edges {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

type CategoryProductsEdge struct {
	Cursor string   `json:"cursor"`
	Node   *Product `json:"node"`
}

func (CategoryProductsEdge) IsEdge()                {}
func (this CategoryProductsEdge) GetCursor() string { return this.Cursor }
func (this CategoryProductsEdge) GetNode() Node     { return *this.Node }

type CategorySort struct {
	SortField CategorySortField `json:"sortField"`
	SortOrder SortOrder         `json:"sortOrder"`
}

type CreateCategoryInput struct {
	Name string `json:"name"`
}

type CreateProductInput struct {
	Name        string  `json:"name"`
	Price       float64 `json:"price"`
	Description string  `json:"description"`
	Image       string  `json:"image"`
	Category    string  `json:"category"`
}

type FilterFloat struct {
	LogicalOperator *LogicalOperator `json:"logicalOperator"`
	Eq              *float64         `json:"eq"`
	Ne              *float64         `json:"ne"`
	In              []*float64       `json:"in"`
	Nin             []*float64       `json:"nin"`
	Gt              *float64         `json:"gt"`
	Gte             *float64         `json:"gte"`
	Lt              *float64         `json:"lt"`
	Lte             *float64         `json:"lte"`
}

type FilterID struct {
	Eq  *string   `json:"eq"`
	Ne  *string   `json:"ne"`
	In  []*string `json:"in"`
	Nin []*string `json:"nin"`
}

type FilterInt struct {
	LogicalOperator *LogicalOperator `json:"logicalOperator"`
	Eq              *int             `json:"eq"`
	Ne              *int             `json:"ne"`
	Gt              *int             `json:"gt"`
	Gte             *int             `json:"gte"`
	Lt              *int             `json:"lt"`
	Lte             *int             `json:"lte"`
	In              []*int           `json:"in"`
	Nin             []*int           `json:"nin"`
}

type FilterString struct {
	LogicalOperator *LogicalOperator `json:"logicalOperator"`
	Eq              *string          `json:"eq"`
	Ne              *string          `json:"ne"`
	In              []*string        `json:"in"`
	Nin             []*string        `json:"nin"`
	Regex           *string          `json:"regex"`
	Nregex          *string          `json:"nregex"`
}

type InternalServerError struct {
	Message string `json:"message"`
}

func (InternalServerError) IsError()                {}
func (this InternalServerError) GetMessage() string { return this.Message }

func (InternalServerError) IsCreateProductResult() {}

func (InternalServerError) IsUpdateProductResult() {}

func (InternalServerError) IsDeleteProductResult() {}

func (InternalServerError) IsCreateCategoryResult() {}

func (InternalServerError) IsUpdateCategoryResult() {}

func (InternalServerError) IsDeleteCategoryResult() {}

type PageInfo struct {
	HasNextPage     bool    `json:"hasNextPage"`
	HasPreviousPage bool    `json:"hasPreviousPage"`
	StartCursor     *string `json:"startCursor"`
	EndCursor       *string `json:"endCursor"`
}

type Product struct {
	ID          string    `json:"id"`
	Name        string    `json:"name"`
	Price       float64   `json:"price"`
	Description string    `json:"description"`
	Image       string    `json:"image"`
	Category    *Category `json:"category"`
}

func (Product) IsNode()            {}
func (this Product) GetID() string { return this.ID }

func (Product) IsCreateProductResult() {}

func (Product) IsUpdateProductResult() {}

func (Product) IsDeleteProductResult() {}

type ProductConnection struct {
	Edges    []*ProductEdge `json:"edges"`
	PageInfo *PageInfo      `json:"pageInfo"`
}

func (ProductConnection) IsConnection()               {}
func (this ProductConnection) GetPageInfo() *PageInfo { return this.PageInfo }
func (this ProductConnection) GetEdges() []Edge {
	if this.Edges == nil {
		return nil
	}
	interfaceSlice := make([]Edge, 0, len(this.Edges))
	for _, concrete := range this.Edges {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}

type ProductEdge struct {
	Cursor string   `json:"cursor"`
	Node   *Product `json:"node"`
}

func (ProductEdge) IsEdge()                {}
func (this ProductEdge) GetCursor() string { return this.Cursor }
func (this ProductEdge) GetNode() Node     { return *this.Node }

type ProductFilter struct {
	Name        *FilterString `json:"name"`
	Price       *FilterFloat  `json:"price"`
	Description *FilterString `json:"description"`
	Image       *FilterString `json:"image"`
	Category    *FilterID     `json:"category"`
}

type ProductSort struct {
	SortField ProductSortField `json:"sortField"`
	SortOrder SortOrder        `json:"sortOrder"`
}

type UpdateCategoryInput struct {
	Name string `json:"name"`
}

type UpdateProductInput struct {
	Name        string  `json:"name"`
	Price       float64 `json:"price"`
	Description string  `json:"description"`
	Image       string  `json:"image"`
	Category    string  `json:"category"`
}

type CategorySortField string

const (
	CategorySortFieldName CategorySortField = "NAME"
)

var AllCategorySortField = []CategorySortField{
	CategorySortFieldName,
}

func (e CategorySortField) IsValid() bool {
	switch e {
	case CategorySortFieldName:
		return true
	}
	return false
}

func (e CategorySortField) String() string {
	return string(e)
}

func (e *CategorySortField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CategorySortField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CategorySortField", str)
	}
	return nil
}

func (e CategorySortField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type LogicalOperator string

const (
	LogicalOperatorAnd LogicalOperator = "AND"
	LogicalOperatorOr  LogicalOperator = "OR"
)

var AllLogicalOperator = []LogicalOperator{
	LogicalOperatorAnd,
	LogicalOperatorOr,
}

func (e LogicalOperator) IsValid() bool {
	switch e {
	case LogicalOperatorAnd, LogicalOperatorOr:
		return true
	}
	return false
}

func (e LogicalOperator) String() string {
	return string(e)
}

func (e *LogicalOperator) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = LogicalOperator(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid LogicalOperator", str)
	}
	return nil
}

func (e LogicalOperator) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ProductSortField string

const (
	ProductSortFieldName        ProductSortField = "NAME"
	ProductSortFieldPrice       ProductSortField = "PRICE"
	ProductSortFieldDescription ProductSortField = "DESCRIPTION"
	ProductSortFieldImage       ProductSortField = "IMAGE"
	ProductSortFieldCategory    ProductSortField = "CATEGORY"
)

var AllProductSortField = []ProductSortField{
	ProductSortFieldName,
	ProductSortFieldPrice,
	ProductSortFieldDescription,
	ProductSortFieldImage,
	ProductSortFieldCategory,
}

func (e ProductSortField) IsValid() bool {
	switch e {
	case ProductSortFieldName, ProductSortFieldPrice, ProductSortFieldDescription, ProductSortFieldImage, ProductSortFieldCategory:
		return true
	}
	return false
}

func (e ProductSortField) String() string {
	return string(e)
}

func (e *ProductSortField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProductSortField(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProductSortField", str)
	}
	return nil
}

func (e ProductSortField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type SortOrder string

const (
	SortOrderAsc  SortOrder = "ASC"
	SortOrderDesc SortOrder = "DESC"
)

var AllSortOrder = []SortOrder{
	SortOrderAsc,
	SortOrderDesc,
}

func (e SortOrder) IsValid() bool {
	switch e {
	case SortOrderAsc, SortOrderDesc:
		return true
	}
	return false
}

func (e SortOrder) String() string {
	return string(e)
}

func (e *SortOrder) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = SortOrder(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid SortOrder", str)
	}
	return nil
}

func (e SortOrder) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
